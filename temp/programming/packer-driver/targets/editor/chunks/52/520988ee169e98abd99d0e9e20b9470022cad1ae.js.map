{"version":3,"sources":["file:///Users/geliang/web/dibai/hall/assets/script/utils/TaskScheduler.ts"],"names":["Task","TaskScheduler","taskMap","constructor","fn","name","Date","parse","parseInt","Math","random","isAutoDestroy","hasDone","isExecute","isForceComplete","doneHandlerMap","startUpHandler","finally","bindFinally","execute","console","error","forEach","item","handler","key","e","subscribeDone","isClear","push","forceComplete","isDoneExecute","doneFn","isDone","asyncQueue","syncQueue","length","start","_task","shift","undefined","joinqQueue","task","sync","autoDestroy","stopQueue","destoryQueue","TaskSchedulerDefault","taskScheduler"],"mappings":"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","sourcesContent":["import { math } from \"cc\"\r\nimport { gameBoardViewModel } from \"../subGame/fruit777\"\r\nimport Singleton from \"./Singleton\"\r\n\r\n/**\r\n * 任务类，可以放置一段待执行的代码，且将任务完成点放在代码的任一位置，任务完成的函数亦可支持执行多个代码段。之后，随时自由控制启动任务此，并按照预制的方案执行完成的函数\r\n * \r\n *  使用方式\r\n\r\n const taskStacker = new TaskStacker((done) => {\r\n    window.setTimeout(() => {\r\n      done()\r\n    }, 1000)\r\n  })\r\n\r\n  // some time\r\n\r\n  taskStacker.subscribeDone('done_1', (key) => {\r\n    console.log('done', key)\r\n  })\r\n  taskStacker.subscribeDone('done_2', (key) => {\r\n    console.log('done', key)\r\n  })\r\n\r\n  // finally\r\n\r\n  taskStacker.execute()\r\n\r\n  // 不想等待，提前执行\r\n\r\n  taskStacker.forceComplete()\r\n\r\n  推荐配合使用调度器TaskScheduler\r\n */\r\n\r\nconst taskMap = {}\r\nexport class Task {\r\n  /**切记，声明主执行函数中，done一定要确保执行，否则任务无法停止，若使用了任务调度器，那么队列将会被挂起 */\r\n  constructor(fn: (done: Function) => void, name?: string) {\r\n    this.startUpHandler = fn\r\n    name && (this.name = name)\r\n    this.isExecute = false\r\n    // taskMap[this.name] = this\r\n  }\r\n  public name: string = `task_${Date.parse(new Date() as any) + parseInt((Math.random() * 1000) + '')}`\r\n  /**完成后是否自爆，为调度器预留使用的字段，不要手贱自行设置。当然也有脱离调度器使用的方式，但是劳资不告诉你，要么自己看代码 */\r\n  public isAutoDestroy: boolean = true\r\n  /**任务是否已经完整执行了，要重启，需要重新执行execute函数 */\r\n  private hasDone: boolean = true\r\n  public isExecute: boolean = false\r\n  private isForceComplete: boolean = false\r\n  private doneHandlerMap: Array<{ key: string, handler: (key: string) => void }> = []\r\n  private startUpHandler: (done: Function) => void\r\n  /**结束 */\r\n  private finally() { }\r\n  /**绑定任务执行完之后的函数，主要为任务调度器使用，判断是否需要销毁，所以，若使用了调度器，请勿手动调用此函数，因为调用了也没啥卵用，会被覆盖掉 */\r\n  public bindFinally(fn: () => void) { this.finally = fn }\r\n  public execute() {\r\n    if (!this.hasDone) {\r\n      console.error('The task has not been completed')\r\n      return\r\n    }\r\n    this.hasDone = false\r\n    try {\r\n      this.startUpHandler(() => {\r\n        try {\r\n          if (!this.isForceComplete) {\r\n            //有可能已经提前终止了任务\r\n            this.doneHandlerMap.forEach(item => item.handler(item.key))\r\n            this.hasDone = true\r\n            this.isExecute = true\r\n            this.finally()\r\n          }\r\n        } catch (e) {\r\n          console.error(e)\r\n        }\r\n      })\r\n    } catch (e) {\r\n      console.error(e)\r\n    }\r\n  }\r\n  /**\r\n   * 声明完成的事件函数\r\n   * @param key 识别字符串\r\n   * @param handler 函数体\r\n   * @param isClear 加入之前是否删除之前的完成函数，为避免意外的情况，慎用（一般情况下，若要重启函数，且要清除之前已经执行过的函数，可以置为true）\r\n   * @returns \r\n   */\r\n  public subscribeDone(key: string, handler: (key: string) => void, isClear: boolean = false) {\r\n    // this.hasDone && console.warn('The task has been done')\r\n    isClear && (this.doneHandlerMap = [])\r\n    this.doneHandlerMap.push({ key, handler })\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * 越过主函数，提前强制完成\r\n   * @param isDoneExecute 是否还要执行done函数\r\n   */\r\n  public forceComplete(isDoneExecute: boolean = true) {\r\n    this.isForceComplete = true\r\n    isDoneExecute && this.doneHandlerMap.forEach(item => {\r\n      try {\r\n        item.handler(item.key)\r\n      } catch (e) {\r\n        console.error(e)\r\n      }\r\n    })\r\n    this.hasDone = true\r\n    this.isExecute = true\r\n    this.finally()\r\n  }\r\n}\r\n\r\n/**任务调度器，使用方法：TaskScheduler.Instance().joinqQueue(task1, false).joinqQueue(task2, false) \r\n * \r\n * 传入的doneFn是通道里的任务都执行完之后要执行的函数，如果再加入队列，此函数都会在队列执行完之后执行\r\n*/\r\nexport default class TaskScheduler {\r\n  constructor(doneFn?: () => void) {\r\n    this.doneFn = doneFn\r\n    while (this.asyncQueue.length) {\r\n      this.start()\r\n    }\r\n  }\r\n  private isDone: boolean = true\r\n  private doneFn: () => void\r\n  /**干活 */\r\n  private start() {\r\n    if (!this.asyncQueue.length) {\r\n      this.isDone = true\r\n      this.doneFn && this.doneFn()\r\n      return\r\n    }\r\n    let _task = this.asyncQueue.shift()\r\n    _task.bindFinally(() => {\r\n      _task && _task.isAutoDestroy && (_task = undefined)\r\n      this.start()\r\n    })\r\n    _task.execute()\r\n  }\r\n  /**异步队列 */\r\n  private asyncQueue: Task[] = []\r\n  private syncQueue: { [key: string]: Task }\r\n  /**\r\n   * 加入任务调度器\r\n   * @param taskStacker 任务实体\r\n   * @param sync 立即执行，还是排队执行（true:立即执行，false：排队执行）遵循先进先出原则\r\n   * @param autoDestroy 是否执行完之后自动销毁，如果不销毁，可以调用restart重启，默认销毁\r\n   */\r\n  public joinqQueue(task: Task, sync: boolean = false, autoDestroy: boolean = true) {\r\n    if (autoDestroy) {\r\n      task.isAutoDestroy = autoDestroy\r\n      task.bindFinally(() => {\r\n        task = undefined\r\n        // console.log(\"task\", gameBoardViewModel.changeGameTypeTask)\r\n      })\r\n    }\r\n    // sync ? task.execute() : this.asyncQueue.push(task)\r\n    if (sync) {\r\n      task.execute()\r\n      return this\r\n    } else {\r\n      this.asyncQueue.push(task)\r\n    }\r\n    if (this.isDone) {\r\n      this.isDone = false\r\n      this.start()\r\n    }\r\n    return this\r\n  }\r\n  /**\r\n   * 提前终止队列\r\n   * @param isDoneExecute 是否还执行每一个task任务的结束函数\r\n   */\r\n  public stopQueue(isDoneExecute: boolean = true) {\r\n    this.isDone = true\r\n    while (this.asyncQueue.length) {\r\n      const task = this.asyncQueue.shift()\r\n      isDoneExecute && task.forceComplete()\r\n    }\r\n  }\r\n  /**清楚掉所有后续任务队列 */\r\n  public destoryQueue() {\r\n    this.isDone = true\r\n    while (this.asyncQueue.length) {\r\n      const task = this.asyncQueue.shift()\r\n      task.forceComplete(false)\r\n    }\r\n  }\r\n}\r\n\r\nlet taskScheduler: TaskScheduler\r\nexport const TaskSchedulerDefault = () => {\r\n  if (taskScheduler) {\r\n    return taskScheduler\r\n  } else {\r\n    taskScheduler = new TaskScheduler()\r\n    return taskScheduler\r\n  }\r\n}"]}