{"version":3,"sources":["file:///Users/geliang/web/dibai/hall/assets/script/utils/fastEqual/internalTypes.ts"],"names":[],"mappings":";;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AAmHA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["/**\r\n * Cache used to store references to objects, used for circular\r\n * reference checks.\r\n */\r\nexport interface Cache<Key extends object, Value> {\r\n  delete(key: Key): boolean;\r\n  get(key: Key): Value | undefined;\r\n  set(key: Key, value: any): any;\r\n}\r\n\r\nexport interface State<Meta> {\r\n  /**\r\n   * Cache used to identify circular references\r\n   */\r\n  readonly cache: Cache<any, any> | undefined;\r\n  /**\r\n   * Method used to determine equality of nested value.\r\n   */\r\n  readonly equals: InternalEqualityComparator<Meta>;\r\n  /**\r\n   * Additional value that can be used for comparisons.\r\n   */\r\n  meta: Meta;\r\n  /**\r\n   * Whether the equality comparison is strict, meaning it matches\r\n   * all properties (including symbols and non-enumerable properties)\r\n   * with equal shape of descriptors.\r\n   */\r\n  readonly strict: boolean;\r\n}\r\n\r\nexport interface CircularState<Meta> extends State<Meta> {\r\n  readonly cache: Cache<any, any>;\r\n}\r\n\r\nexport interface DefaultState<Meta> extends State<Meta> {\r\n  readonly cache: undefined;\r\n}\r\n\r\nexport interface Dictionary<Value = any> {\r\n  [key: string | symbol]: Value;\r\n  $$typeof?: any;\r\n}\r\n\r\nexport interface ComparatorConfig<Meta> {\r\n  /**\r\n   * Whether the arrays passed are equal in value. In strict mode, this includes\r\n   * additional properties added to the array.\r\n   */\r\n  areArraysEqual: TypeEqualityComparator<any, Meta>;\r\n  /**\r\n   * Whether the dates passed are equal in value.\r\n   */\r\n  areDatesEqual: TypeEqualityComparator<any, Meta>;\r\n  /**\r\n   * Whether the maps passed are equal in value. In strict mode, this includes\r\n   * additional properties added to the map.\r\n   */\r\n  areMapsEqual: TypeEqualityComparator<any, Meta>;\r\n  /**\r\n   * Whether the objects passed are equal in value. In strict mode, this includes\r\n   * non-enumerable properties added to the map, as well as symbol properties.\r\n   */\r\n  areObjectsEqual: TypeEqualityComparator<any, Meta>;\r\n  /**\r\n   * Whether the primitive wrappers passed are equal in value.\r\n   */\r\n  arePrimitiveWrappersEqual: TypeEqualityComparator<any, Meta>;\r\n  /**\r\n   * Whether the regexps passed are equal in value.\r\n   */\r\n  areRegExpsEqual: TypeEqualityComparator<any, Meta>;\r\n  /**\r\n   * Whether the sets passed are equal in value. In strict mode, this includes\r\n   * additional properties added to the set.\r\n   */\r\n  areSetsEqual: TypeEqualityComparator<any, Meta>;\r\n  /**\r\n   * Whether the typed arrays passed are equal in value. In strict mode, this includes\r\n   * additional properties added to the typed array.\r\n   */\r\n  areTypedArraysEqual: TypeEqualityComparator<any, Meta>;\r\n}\r\n\r\nexport type CreateCustomComparatorConfig<Meta> = (\r\n  config: ComparatorConfig<Meta>,\r\n) => Partial<ComparatorConfig<Meta>>;\r\n\r\nexport type CreateState<Meta> = () => {\r\n  cache?: Cache<any, any> | undefined;\r\n  meta?: Meta;\r\n};\r\n\r\nexport type EqualityComparator<Meta> = <A, B>(\r\n  a: A,\r\n  b: B,\r\n  state: State<Meta>,\r\n) => boolean;\r\nexport type AnyEqualityComparator<Meta> = (\r\n  a: any,\r\n  b: any,\r\n  state: State<Meta>,\r\n) => boolean;\r\n\r\nexport type EqualityComparatorCreator<Meta> = (\r\n  fn: EqualityComparator<Meta>,\r\n) => InternalEqualityComparator<Meta>;\r\n\r\nexport type InternalEqualityComparator<Meta> = (\r\n  a: any,\r\n  b: any,\r\n  indexOrKeyA: any,\r\n  indexOrKeyB: any,\r\n  parentA: any,\r\n  parentB: any,\r\n  state: State<Meta>,\r\n) => boolean;\r\n\r\n// We explicitly check for primitive wrapper types\r\n// eslint-disable-next-line @typescript-eslint/ban-types\r\nexport type PrimitiveWrapper = Boolean | Number | String;\r\n\r\n/**\r\n * Type which encompasses possible instances of TypedArray\r\n * classes.\r\n *\r\n * **NOTE**: This does not include `BigInt64Array` and\r\n * `BitUint64Array` because those are part of ES2020 and\r\n * not supported by certain TS configurations. If using\r\n * either in `areTypedArraysEqual`, you can cast the\r\n * instance as `TypedArray` and it will work as expected,\r\n * because runtime checks will still work for those classes.\r\n */\r\nexport type TypedArray =\r\n  | Float32Array\r\n  | Float64Array\r\n  | Int8Array\r\n  | Int16Array\r\n  | Int32Array\r\n  | Uint16Array\r\n  | Uint32Array\r\n  | Uint8Array\r\n  | Uint8ClampedArray;\r\n\r\nexport type TypeEqualityComparator<Type, Meta = undefined> = (\r\n  a: Type,\r\n  b: Type,\r\n  state: State<Meta>,\r\n) => boolean;\r\n\r\nexport interface CustomEqualCreatorOptions<Meta> {\r\n  /**\r\n   * Whether circular references should be supported. It causes the\r\n   * comparison to be slower, but for objects that have circular references\r\n   * it is required to avoid stack overflows.\r\n   */\r\n  circular?: boolean;\r\n  /**\r\n   * Create a custom configuration of type-specific equality comparators.\r\n   * This receives the default configuration, which allows either replacement\r\n   * or supersetting of the default methods.\r\n   */\r\n  createCustomConfig?: CreateCustomComparatorConfig<Meta>;\r\n  /**\r\n   * Create a custom internal comparator, which is used as an override to the\r\n   * default entry point for nested value equality comparisons. This is often\r\n   * used for doing custom logic for specific types (such as handling a specific\r\n   * class instance differently than other objects) or to incorporate `meta` in\r\n   * the comparison. See the recipes for examples.\r\n   */\r\n  createInternalComparator?: (\r\n    compare: EqualityComparator<Meta>,\r\n  ) => InternalEqualityComparator<Meta>;\r\n  /**\r\n   * Create a custom `state` object passed between the methods. This allows for\r\n   * custom `cache` and/or `meta` values to be used.\r\n   */\r\n  createState?: CreateState<Meta>;\r\n  /**\r\n   * Whether the equality comparison is strict, meaning it matches\r\n   * all properties (including symbols and non-enumerable properties)\r\n   * with equal shape of descriptors.\r\n   */\r\n  strict?: boolean;\r\n}\r\n"]}