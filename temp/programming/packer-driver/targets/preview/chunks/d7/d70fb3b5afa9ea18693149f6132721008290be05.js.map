{"version":3,"sources":["file:///Users/geliang/web/dibai/hall/assets/script/utils/fastEqual/comparator.ts"],"names":["createEqualityComparator","areArraysEqual","areDatesEqual","areMapsEqual","areObjectsEqual","arePrimitiveWrappersEqual","areRegExpsEqual","areSetsEqual","areTypedArraysEqual","comparator","a","b","state","constructor","Object","isArray","isTypedArray","Date","RegExp","Map","Set","tag","getTag","DATE_TAG","REG_EXP_TAG","MAP_TAG","SET_TAG","OBJECT_TAG","then","ARGUMENTS_TAG","BOOLEAN_TAG","NUMBER_TAG","STRING_TAG","createEqualityComparatorConfig","circular","createCustomConfig","strict","config","assign","createInternalEqualityComparator","compare","_indexOrKeyA","_indexOrKeyB","_parentA","_parentB","createIsEqual","createState","equals","isEqual","cache","WeakMap","undefined","meta","areArraysEqualDefault","areDatesEqualDefault","areMapsEqualDefault","areObjectsEqualDefault","areObjectsEqualStrictDefault","areObjectsEqualStrict","arePrimitiveWrappersEqualDefault","areRegExpsEqualDefault","areSetsEqualDefault","combineComparators","createIsCircular","Array","ArrayBuffer","isView","prototype","toString","call","bind"],"mappings":"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","sourcesContent":["import {\r\n  areArraysEqual as areArraysEqualDefault,\r\n  areDatesEqual as areDatesEqualDefault,\r\n  areMapsEqual as areMapsEqualDefault,\r\n  areObjectsEqual as areObjectsEqualDefault,\r\n  areObjectsEqualStrict as areObjectsEqualStrictDefault,\r\n  arePrimitiveWrappersEqual as arePrimitiveWrappersEqualDefault,\r\n  areRegExpsEqual as areRegExpsEqualDefault,\r\n  areSetsEqual as areSetsEqualDefault,\r\n  areTypedArraysEqual,\r\n} from './equals';\r\nimport { combineComparators, createIsCircular } from './utils';\r\nimport type {\r\n  ComparatorConfig,\r\n  CreateState,\r\n  CustomEqualCreatorOptions,\r\n  EqualityComparator,\r\n  InternalEqualityComparator,\r\n  State,\r\n} from './internalTypes';\r\n\r\nconst ARGUMENTS_TAG = '[object Arguments]';\r\nconst BOOLEAN_TAG = '[object Boolean]';\r\nconst DATE_TAG = '[object Date]';\r\nconst MAP_TAG = '[object Map]';\r\nconst NUMBER_TAG = '[object Number]';\r\nconst OBJECT_TAG = '[object Object]';\r\nconst REG_EXP_TAG = '[object RegExp]';\r\nconst SET_TAG = '[object Set]';\r\nconst STRING_TAG = '[object String]';\r\n\r\nconst { isArray } = Array;\r\nconst isTypedArray =\r\n  typeof ArrayBuffer === 'function' && ArrayBuffer.isView\r\n    ? ArrayBuffer.isView\r\n    : null;\r\nconst { assign } = Object;\r\nconst getTag = Object.prototype.toString.call.bind(\r\n  Object.prototype.toString,\r\n) as (a: object) => string;\r\n\r\ninterface CreateIsEqualOptions<Meta> {\r\n  circular: boolean;\r\n  comparator: EqualityComparator<Meta>;\r\n  createState: CreateState<Meta> | undefined;\r\n  equals: InternalEqualityComparator<Meta>;\r\n  strict: boolean;\r\n}\r\n\r\n/**\r\n * Create a comparator method based on the type-specific equality comparators passed.\r\n */\r\nexport function createEqualityComparator<Meta>({\r\n  areArraysEqual,\r\n  areDatesEqual,\r\n  areMapsEqual,\r\n  areObjectsEqual,\r\n  arePrimitiveWrappersEqual,\r\n  areRegExpsEqual,\r\n  areSetsEqual,\r\n  areTypedArraysEqual,\r\n}: ComparatorConfig<Meta>): EqualityComparator<Meta> {\r\n  /**\r\n   * compare the value of the two objects and return true if they are equivalent in values\r\n   */\r\n  return function comparator(a: any, b: any, state: State<Meta>): boolean {\r\n    // If the items are strictly equal, no need to do a value comparison.\r\n    if (a === b) {\r\n      return true;\r\n    }\r\n\r\n    // If the items are not non-nullish objects, then the only possibility\r\n    // of them being equal but not strictly is if they are both `NaN`. Since\r\n    // `NaN` is uniquely not equal to itself, we can use self-comparison of\r\n    // both objects, which is faster than `isNaN()`.\r\n    if (\r\n      a == null ||\r\n      b == null ||\r\n      typeof a !== 'object' ||\r\n      typeof b !== 'object'\r\n    ) {\r\n      return a !== a && b !== b;\r\n    }\r\n\r\n    const constructor = a.constructor;\r\n\r\n    // Checks are listed in order of commonality of use-case:\r\n    //   1. Common complex object types (plain object, array)\r\n    //   2. Common data values (date, regexp)\r\n    //   3. Less-common complex object types (map, set)\r\n    //   4. Less-common data values (promise, primitive wrappers)\r\n    // Inherently this is both subjective and assumptive, however\r\n    // when reviewing comparable libraries in the wild this order\r\n    // appears to be generally consistent.\r\n\r\n    // Constructors should match, otherwise there is potential for false positives\r\n    // between class and subclass or custom object and POJO.\r\n    if (constructor !== b.constructor) {\r\n      return false;\r\n    }\r\n\r\n    // `isPlainObject` only checks against the object's own realm. Cross-realm\r\n    // comparisons are rare, and will be handled in the ultimate fallback, so\r\n    // we can avoid capturing the string tag.\r\n    if (constructor === Object) {\r\n      return areObjectsEqual(a, b, state);\r\n    }\r\n\r\n    // `isArray()` works on subclasses and is cross-realm, so we can avoid capturing\r\n    // the string tag or doing an `instanceof` check.\r\n    if (isArray(a)) {\r\n      return areArraysEqual(a, b, state);\r\n    }\r\n\r\n    // `isTypedArray()` works on all possible TypedArray classes, so we can avoid\r\n    // capturing the string tag or comparing against all possible constructors.\r\n    if (isTypedArray != null && isTypedArray(a)) {\r\n      return areTypedArraysEqual(a, b, state);\r\n    }\r\n\r\n    // Try to fast-path equality checks for other complex object types in the\r\n    // same realm to avoid capturing the string tag. Strict equality is used\r\n    // instead of `instanceof` because it is more performant for the common\r\n    // use-case. If someone is subclassing a native class, it will be handled\r\n    // with the string tag comparison.\r\n\r\n    if (constructor === Date) {\r\n      return areDatesEqual(a, b, state);\r\n    }\r\n\r\n    if (constructor === RegExp) {\r\n      return areRegExpsEqual(a, b, state);\r\n    }\r\n\r\n    if (constructor === Map) {\r\n      return areMapsEqual(a, b, state);\r\n    }\r\n\r\n    if (constructor === Set) {\r\n      return areSetsEqual(a, b, state);\r\n    }\r\n\r\n    // Since this is a custom object, capture the string tag to determing its type.\r\n    // This is reasonably performant in modern environments like v8 and SpiderMonkey.\r\n    const tag = getTag(a);\r\n\r\n    if (tag === DATE_TAG) {\r\n      return areDatesEqual(a, b, state);\r\n    }\r\n\r\n    if (tag === REG_EXP_TAG) {\r\n      return areRegExpsEqual(a, b, state);\r\n    }\r\n\r\n    if (tag === MAP_TAG) {\r\n      return areMapsEqual(a, b, state);\r\n    }\r\n\r\n    if (tag === SET_TAG) {\r\n      return areSetsEqual(a, b, state);\r\n    }\r\n\r\n    if (tag === OBJECT_TAG) {\r\n      // The exception for value comparison is custom `Promise`-like class instances. These should\r\n      // be treated the same as standard `Promise` objects, which means strict equality, and if\r\n      // it reaches this point then that strict equality comparison has already failed.\r\n      return (\r\n        typeof a.then !== 'function' &&\r\n        typeof b.then !== 'function' &&\r\n        areObjectsEqual(a, b, state)\r\n      );\r\n    }\r\n\r\n    // If an arguments tag, it should be treated as a standard object.\r\n    if (tag === ARGUMENTS_TAG) {\r\n      return areObjectsEqual(a, b, state);\r\n    }\r\n\r\n    // As the penultimate fallback, check if the values passed are primitive wrappers. This\r\n    // is very rare in modern JS, which is why it is deprioritized compared to all other object\r\n    // types.\r\n    if (tag === BOOLEAN_TAG || tag === NUMBER_TAG || tag === STRING_TAG) {\r\n      return arePrimitiveWrappersEqual(a, b, state);\r\n    }\r\n\r\n    // If not matching any tags that require a specific type of comparison, then we hard-code false because\r\n    // the only thing remaining is strict equality, which has already been compared. This is for a few reasons:\r\n    //   - Certain types that cannot be introspected (e.g., `WeakMap`). For these types, this is the only\r\n    //     comparison that can be made.\r\n    //   - For types that can be introspected, but rarely have requirements to be compared\r\n    //     (`ArrayBuffer`, `DataView`, etc.), the cost is avoided to prioritize the common\r\n    //     use-cases (may be included in a future release, if requested enough).\r\n    //   - For types that can be introspected but do not have an objective definition of what\r\n    //     equality is (`Error`, etc.), the subjective decision is to be conservative and strictly compare.\r\n    // In all cases, these decisions should be reevaluated based on changes to the language and\r\n    // common development practices.\r\n    return false;\r\n  };\r\n}\r\n\r\n/**\r\n * Create the configuration object used for building comparators.\r\n */\r\nexport function createEqualityComparatorConfig<Meta>({\r\n  circular,\r\n  createCustomConfig,\r\n  strict,\r\n}: CustomEqualCreatorOptions<Meta>): ComparatorConfig<Meta> {\r\n  let config = {\r\n    areArraysEqual: strict\r\n      ? areObjectsEqualStrictDefault\r\n      : areArraysEqualDefault,\r\n    areDatesEqual: areDatesEqualDefault,\r\n    areMapsEqual: strict\r\n      ? combineComparators(areMapsEqualDefault, areObjectsEqualStrictDefault)\r\n      : areMapsEqualDefault,\r\n    areObjectsEqual: strict\r\n      ? areObjectsEqualStrictDefault\r\n      : areObjectsEqualDefault,\r\n    arePrimitiveWrappersEqual: arePrimitiveWrappersEqualDefault,\r\n    areRegExpsEqual: areRegExpsEqualDefault,\r\n    areSetsEqual: strict\r\n      ? combineComparators(areSetsEqualDefault, areObjectsEqualStrictDefault)\r\n      : areSetsEqualDefault,\r\n    areTypedArraysEqual: strict\r\n      ? areObjectsEqualStrictDefault\r\n      : areTypedArraysEqual,\r\n  };\r\n\r\n  if (createCustomConfig) {\r\n    config = assign({}, config, createCustomConfig(config));\r\n  }\r\n\r\n  if (circular) {\r\n    const areArraysEqual = createIsCircular(config.areArraysEqual);\r\n    const areMapsEqual = createIsCircular(config.areMapsEqual);\r\n    const areObjectsEqual = createIsCircular(config.areObjectsEqual);\r\n    const areSetsEqual = createIsCircular(config.areSetsEqual);\r\n\r\n    config = assign({}, config, {\r\n      areArraysEqual,\r\n      areMapsEqual,\r\n      areObjectsEqual,\r\n      areSetsEqual,\r\n    });\r\n  }\r\n\r\n  return config;\r\n}\r\n\r\n/**\r\n * Default equality comparator pass-through, used as the standard `isEqual` creator for\r\n * use inside the built comparator.\r\n */\r\nexport function createInternalEqualityComparator<Meta>(\r\n  compare: EqualityComparator<Meta>,\r\n): InternalEqualityComparator<Meta> {\r\n  return function (\r\n    a: any,\r\n    b: any,\r\n    _indexOrKeyA: any,\r\n    _indexOrKeyB: any,\r\n    _parentA: any,\r\n    _parentB: any,\r\n    state: State<Meta>,\r\n  ) {\r\n    return compare(a, b, state);\r\n  };\r\n}\r\n\r\n/**\r\n * Create the `isEqual` function used by the consuming application.\r\n */\r\nexport function createIsEqual<Meta>({\r\n  circular,\r\n  comparator,\r\n  createState,\r\n  equals,\r\n  strict,\r\n}: CreateIsEqualOptions<Meta>) {\r\n  if (createState) {\r\n    return function isEqual<A, B>(a: A, b: B): boolean {\r\n      const { cache = circular ? new WeakMap() : undefined, meta } =\r\n        createState!();\r\n\r\n      return comparator(a, b, {\r\n        cache,\r\n        equals,\r\n        meta,\r\n        strict,\r\n      } as State<Meta>);\r\n    };\r\n  }\r\n\r\n  if (circular) {\r\n    return function isEqual<A, B>(a: A, b: B): boolean {\r\n      return comparator(a, b, {\r\n        cache: new WeakMap(),\r\n        equals,\r\n        meta: undefined as Meta,\r\n        strict,\r\n      } as State<Meta>);\r\n    };\r\n  }\r\n\r\n  const state = {\r\n    cache: undefined,\r\n    equals,\r\n    meta: undefined,\r\n    strict,\r\n  } as State<Meta>;\r\n\r\n  return function isEqual<A, B>(a: A, b: B): boolean {\r\n    return comparator(a, b, state);\r\n  };\r\n}\r\n"]}